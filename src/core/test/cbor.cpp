/*
 * Copyright 2025 Aurora Operations, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <gtest/gtest.h>
#include <nat20/cbor.h>
#include <nat20/stream.h>
#include <nat20/testing/test_utils.h>

#include <cstdint>
#include <tuple>
#include <variant>
#include <vector>

class CborIntegerTestFixture
    : public testing::TestWithParam<
          std::tuple<std::variant<uint64_t, int64_t>, std::vector<uint8_t>>> {};

INSTANTIATE_TEST_CASE_P(
    CborIntegerTestInstance,
    CborIntegerTestFixture,
    testing::Values(
        /* CBOR encoding encoding size boundary conditions. */
        std::tuple(UINT64_C(0), std::vector<uint8_t>{0x00}),
        std::tuple(UINT64_C(1), std::vector<uint8_t>{0x01}),
        std::tuple(UINT64_C(23), std::vector<uint8_t>{0x17}),
        std::tuple(UINT64_C(24), std::vector<uint8_t>{0x18, 0x18}),
        std::tuple(UINT64_C(255), std::vector<uint8_t>{0x18, 0xff}),
        std::tuple(UINT64_C(256), std::vector<uint8_t>{0x19, 0x01, 0x00}),
        std::tuple(UINT64_C(0xffff), std::vector<uint8_t>{0x19, 0xff, 0xff}),
        std::tuple(UINT64_C(0x10000), std::vector<uint8_t>{0x1a, 0x00, 0x01, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffff), std::vector<uint8_t>{0x1a, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(UINT64_C(0x100000000),
                   std::vector<uint8_t>{0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffffffffffff),
                   std::vector<uint8_t>{0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}),
        /* Repeat the same constants as above but force using the
         * the indirection through n20_cbor_write_int. */
        std::tuple(INT64_C(0), std::vector<uint8_t>{0x00}),
        std::tuple(INT64_C(1), std::vector<uint8_t>{0x01}),
        std::tuple(INT64_C(23), std::vector<uint8_t>{0x17}),
        std::tuple(INT64_C(24), std::vector<uint8_t>{0x18, 0x18}),
        std::tuple(INT64_C(255), std::vector<uint8_t>{0x18, 0xff}),
        std::tuple(INT64_C(256), std::vector<uint8_t>{0x19, 0x01, 0x00}),
        std::tuple(INT64_C(0xffff), std::vector<uint8_t>{0x19, 0xff, 0xff}),
        std::tuple(INT64_C(0x10000), std::vector<uint8_t>{0x1a, 0x00, 0x01, 0x00, 0x00}),
        std::tuple(INT64_C(0xffffffff), std::vector<uint8_t>{0x1a, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(INT64_C(0x100000000),
                   std::vector<uint8_t>{0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}),
        std::tuple(INT64_MAX,
                   std::vector<uint8_t>{0x1b, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(INT64_C(-1), std::vector<uint8_t>{0x20}),
        std::tuple(INT64_C(-24), std::vector<uint8_t>{0x37}),
        std::tuple(INT64_C(-25), std::vector<uint8_t>{0x38, 0x18}),
        std::tuple(INT64_C(-256), std::vector<uint8_t>{0x38, 0xff}),
        std::tuple(INT64_C(-257), std::vector<uint8_t>{0x39, 0x01, 0x00}),
        std::tuple(INT64_C(-65536), std::vector<uint8_t>{0x39, 0xff, 0xff}),
        std::tuple(INT64_C(-65537), std::vector<uint8_t>{0x3a, 0x00, 0x01, 0x00, 0x00}),
        std::tuple(INT64_C(-4294967296), std::vector<uint8_t>{0x3a, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(INT64_C(-4294967297),
                   std::vector<uint8_t>{0x3b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}),
        /* This is not the lowest integer that can be represented with
         * CBOR major type 1, but it is the lowest that can be represented
         * using 64 bits 2s-complement. And thus the limit of the
         * integer encoding functions as of now. */
        std::tuple(INT64_MIN,
                   std::vector<uint8_t>{0x3b, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}),

        /* Known OpenDICE label values. */
        std::tuple(INT64_C(-4670545), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x50}),
        std::tuple(INT64_C(-4670546), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x51}),
        std::tuple(INT64_C(-4670547), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x52}),
        std::tuple(INT64_C(-4670548), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x53}),
        std::tuple(INT64_C(-4670549), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x54}),
        std::tuple(INT64_C(-4670550), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x55}),
        std::tuple(INT64_C(-4670551), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x56}),
        std::tuple(INT64_C(-4670552), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x57}),
        std::tuple(INT64_C(-4670553), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x58}),
        std::tuple(INT64_C(-4670554), std::vector<uint8_t>{0x3a, 0x00, 0x47, 0x44, 0x59})));

TEST_P(CborIntegerTestFixture, CborIntegerTest) {
    auto [integer, encoding] = GetParam();

    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    if (std::holds_alternative<uint64_t>(integer)) {
        n20_cbor_write_uint(&s, std::get<uint64_t>(integer));
    } else {
        n20_cbor_write_int(&s, std::get<int64_t>(integer));
    }

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);
    ASSERT_EQ(got_encoding, encoding);
}

TEST(CborTests, CborWriteNullTest) {
    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_cbor_write_null(&s);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);

    ASSERT_EQ(bytes_written, 1);
    ASSERT_EQ(got_encoding, std::vector<uint8_t>{0xf6});
}

TEST(CborTests, CborWriteBoolTest) {
    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_cbor_write_bool(&s, true);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);

    ASSERT_EQ(bytes_written, 1);
    ASSERT_EQ(got_encoding, std::vector<uint8_t>{0xf5});

    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_cbor_write_bool(&s, false);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    bytes_written = n20_stream_byte_count(&s);
    got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);

    ASSERT_EQ(bytes_written, 1);
    ASSERT_EQ(got_encoding, std::vector<uint8_t>{0xf4});
}

class CborTagTestFixture
    : public testing::TestWithParam<std::tuple<uint64_t, std::vector<uint8_t>>> {};

INSTANTIATE_TEST_CASE_P(
    CborTagTestInstance,
    CborTagTestFixture,
    testing::Values(
        /* CBOR encoding encoding size boundary conditions. */
        std::tuple(UINT64_C(0), std::vector<uint8_t>{0xc0}),
        std::tuple(UINT64_C(1), std::vector<uint8_t>{0xc1}),
        std::tuple(UINT64_C(23), std::vector<uint8_t>{0xd7}),
        std::tuple(UINT64_C(24), std::vector<uint8_t>{0xd8, 0x18}),
        std::tuple(UINT64_C(255), std::vector<uint8_t>{0xd8, 0xff}),
        std::tuple(UINT64_C(256), std::vector<uint8_t>{0xd9, 0x01, 0x00}),
        std::tuple(UINT64_C(0xffff), std::vector<uint8_t>{0xd9, 0xff, 0xff}),
        std::tuple(UINT64_C(0x10000), std::vector<uint8_t>{0xda, 0x00, 0x01, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffff), std::vector<uint8_t>{0xda, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(UINT64_C(0x100000000),
                   std::vector<uint8_t>{0xdb, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffffffffffff),
                   std::vector<uint8_t>{0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff})));

TEST_P(CborTagTestFixture, CborTagTest) {
    auto [integer, encoding] = GetParam();

    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_cbor_write_tag(&s, integer);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);
    ASSERT_EQ(got_encoding, encoding);
}

TEST(CborTests, CborWriteByteStringTest) {
    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    uint8_t bytes[] = {0x01, 0x02, 0x03, 0x04};
    n20_cbor_write_byte_string(&s, {.size = sizeof(bytes), .buffer = bytes});

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);

    auto want_encoding = std::vector<uint8_t>{0x44, 0x01, 0x02, 0x03, 0x04};

    ASSERT_EQ(bytes_written, 5);
    ASSERT_EQ(got_encoding, want_encoding);
}

TEST(CborTests, CborWriteStringTest) {
    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_string_slice_t str = N20_STR_C("Hello");
    n20_cbor_write_text_string(&s, str);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);

    auto want_encoding = std::vector<uint8_t>{0x65, 0x48, 0x65, 0x6c, 0x6c, 0x6f};

    ASSERT_EQ(bytes_written, 6);
    ASSERT_EQ(got_encoding, want_encoding);
}

class CborArrayHeaderTestFixture
    : public testing::TestWithParam<std::tuple<uint64_t, std::vector<uint8_t>>> {};

INSTANTIATE_TEST_CASE_P(
    CborArrayHeaderTestInstance,
    CborArrayHeaderTestFixture,
    testing::Values(
        /* CBOR encoding encoding size boundary conditions. */
        std::tuple(UINT64_C(0), std::vector<uint8_t>{0x80}),
        std::tuple(UINT64_C(1), std::vector<uint8_t>{0x81}),
        std::tuple(UINT64_C(23), std::vector<uint8_t>{0x97}),
        std::tuple(UINT64_C(24), std::vector<uint8_t>{0x98, 0x18}),
        std::tuple(UINT64_C(255), std::vector<uint8_t>{0x98, 0xff}),
        std::tuple(UINT64_C(256), std::vector<uint8_t>{0x99, 0x01, 0x00}),
        std::tuple(UINT64_C(0xffff), std::vector<uint8_t>{0x99, 0xff, 0xff}),
        std::tuple(UINT64_C(0x10000), std::vector<uint8_t>{0x9a, 0x00, 0x01, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffff), std::vector<uint8_t>{0x9a, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(UINT64_C(0x100000000),
                   std::vector<uint8_t>{0x9b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffffffffffff),
                   std::vector<uint8_t>{0x9b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff})));

TEST_P(CborArrayHeaderTestFixture, CborArrayHeaderTest) {
    auto [integer, encoding] = GetParam();

    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_cbor_write_array_header(&s, integer);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);
    ASSERT_EQ(got_encoding, encoding);
}

class CborMapHeaderTestFixture
    : public testing::TestWithParam<std::tuple<uint64_t, std::vector<uint8_t>>> {};

INSTANTIATE_TEST_CASE_P(
    CborMapHeaderTestInstance,
    CborMapHeaderTestFixture,
    testing::Values(
        /* CBOR encoding encoding size boundary conditions. */
        std::tuple(UINT64_C(0), std::vector<uint8_t>{0xa0}),
        std::tuple(UINT64_C(1), std::vector<uint8_t>{0xa1}),
        std::tuple(UINT64_C(23), std::vector<uint8_t>{0xb7}),
        std::tuple(UINT64_C(24), std::vector<uint8_t>{0xb8, 0x18}),
        std::tuple(UINT64_C(255), std::vector<uint8_t>{0xb8, 0xff}),
        std::tuple(UINT64_C(256), std::vector<uint8_t>{0xb9, 0x01, 0x00}),
        std::tuple(UINT64_C(0xffff), std::vector<uint8_t>{0xb9, 0xff, 0xff}),
        std::tuple(UINT64_C(0x10000), std::vector<uint8_t>{0xba, 0x00, 0x01, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffff), std::vector<uint8_t>{0xba, 0xff, 0xff, 0xff, 0xff}),
        std::tuple(UINT64_C(0x100000000),
                   std::vector<uint8_t>{0xbb, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}),
        std::tuple(UINT64_C(0xffffffffffffffff),
                   std::vector<uint8_t>{0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff})));

TEST_P(CborMapHeaderTestFixture, CborMapHeaderTest) {
    auto [integer, encoding] = GetParam();

    uint8_t buffer[20];

    n20_stream_t s;
    n20_stream_init(&s, &buffer[0], sizeof(buffer));

    n20_cbor_write_map_header(&s, integer);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    auto got_encoding = std::vector(n20_stream_data(&s), n20_stream_data(&s) + bytes_written);
    ASSERT_EQ(got_encoding, encoding);
}

class COSEExtOpenDiceInputTest
    : public testing::TestWithParam<std::tuple<std::optional<std::vector<uint8_t>>,
                                               std::optional<std::vector<uint8_t>>,
                                               std::optional<std::vector<uint8_t>>,
                                               std::optional<std::vector<uint8_t>>,
                                               std::optional<std::vector<uint8_t>>,
                                               std::optional<std::vector<uint8_t>>,
                                               n20_cwt_open_dice_modes_t const,
                                               std::optional<std::string>,
                                               std::vector<uint8_t> const>> {};

std::vector<uint8_t> const CODE_HASH = {
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
};

std::vector<uint8_t> const CODE_DESCRIPTOR = {0x63, 0x6f, 0x64, 0x65};

std::vector<uint8_t> const CONFIGURATION_INLINE = {
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
};

std::vector<uint8_t> const CONFIGURATION_HASH = {
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
};

std::vector<uint8_t> const CONFIGURATION_DESCRIPTOR = {0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67};

std::vector<uint8_t> const AUTHORITY_HASH = {
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
};

std::vector<uint8_t> const AUTHORITY_DESCRIPTOR = {0x61, 0x75, 0x74, 0x68};

// clang-format off
std::vector<uint8_t> const EXTENSION_WITH_INLINE_CONFIGURATION = {
    // Map header with 10 pairs.
    0xaa,
    // issuer (1).
    0x01,
    // issuer value
    0x78, 0x28, 0x30, 0x31, 0x30, 0x32, 0x30, 0x33, 0x30, 0x34, 0x30, 0x35,
    0x30, 0x36, 0x30, 0x37, 0x30, 0x38, 0x30, 0x39, 0x30, 0x61, 0x30, 0x62,
    0x30, 0x63, 0x30, 0x64, 0x30, 0x65, 0x30, 0x66, 0x31, 0x30, 0x31, 0x31,
    0x31, 0x32, 0x31, 0x33, 0x31, 0x34,
    // subject (2)
    0x02,
    // subject value
    0x78, 0x28, 0x31, 0x35, 0x31, 0x36, 0x31, 0x37, 0x31, 0x38, 0x31, 0x39,
    0x31, 0x61, 0x31, 0x62, 0x31, 0x63, 0x31, 0x64, 0x31, 0x65, 0x31, 0x66,
    0x32, 0x30, 0x32, 0x31, 0x32, 0x32, 0x32, 0x33, 0x32, 0x34, 0x32, 0x35,
    0x32, 0x36, 0x32, 0x37, 0x32, 0x38,
    // code hash (-4670545)
    0x3a, 0x00, 0x47, 0x44, 0x50,
    // code hash value
    0x58, 0x40,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63,
    // code descriptor (-4670546)
    0x3a, 0x00, 0x47, 0x44, 0x51,
    // code descriptor value ("code")
    0x44, 0x63, 0x6f, 0x64, 0x65,
    // configuration descriptor (-4670548)
    0x3a, 0x00, 0x47, 0x44, 0x53,
    0x58, 0x40, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
    // authority hash (-4670549)
    0x3a, 0x00, 0x47, 0x44, 0x54,
    // authority hash value
    0x58, 0x40, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    // authority descriptor (-4670550)
    0x3a, 0x00, 0x47, 0x44, 0x55,
    // authority descriptor value ("auth")
    0x44, 0x61, 0x75, 0x74, 0x68,
    // mode (-4670551)
    0x3a, 0x00, 0x47, 0x44, 0x56,
    // mode value
    0x41, 0x01,
    // Subject public key (-4670552)
    0x3a, 0x00, 0x47, 0x44, 0x57,
    // Subject public key value
    // byte string header
    0x58, 0x51,
    // map header with 6 pairs
    0xa6,
    // Key Type (1)
    0x01,
    // Key type value (EC2)
    0x02,
    // Key Algorithm (3)
    0x03,
    // Key Algorithm value (ESP256: -9)
    0x28,
    // Cose Key Ops (4)
    0x04,
    // Cose Key Ops value (Sign: 1, Verify: 2)
    0x82, 0x01, 0x02,
    // Curve type (-1)
    0x20,
    // Curve type value (P256: 1)
    0x01,
    // X coordinate (-2)
    0x21,
    // X coordinate value
    0x58, 0x20, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    // Y coordinate (-3)
    0x22,
    // Y coordinate value
    0x58, 0x20, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x39, 0x38, 0x37, 0x36,
    0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
    0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,

    // Key Usage (-4670553)
    0x3a, 0x00, 0x47, 0x44, 0x58,
    // Key Usage value
    0x40
};

std::vector<uint8_t> const EXTENSION_WITH_CONFIGURATION_DESCRIPTOR = {
    // Map header with 11 pairs.
    0xab,
    // issuer (1).
    0x01,
    // issuer value
    0x78, 0x28, 0x30, 0x31, 0x30, 0x32, 0x30, 0x33, 0x30, 0x34, 0x30, 0x35,
    0x30, 0x36, 0x30, 0x37, 0x30, 0x38, 0x30, 0x39, 0x30, 0x61, 0x30, 0x62,
    0x30, 0x63, 0x30, 0x64, 0x30, 0x65, 0x30, 0x66, 0x31, 0x30, 0x31, 0x31,
    0x31, 0x32, 0x31, 0x33, 0x31, 0x34,
    // subject (2)
    0x02,
    // subject value
    0x78, 0x28, 0x31, 0x35, 0x31, 0x36, 0x31, 0x37, 0x31, 0x38, 0x31, 0x39,
    0x31, 0x61, 0x31, 0x62, 0x31, 0x63, 0x31, 0x64, 0x31, 0x65, 0x31, 0x66,
    0x32, 0x30, 0x32, 0x31, 0x32, 0x32, 0x32, 0x33, 0x32, 0x34, 0x32, 0x35,
    0x32, 0x36, 0x32, 0x37, 0x32, 0x38,
    // code hash (-4670545)
    0x3a, 0x00, 0x47, 0x44, 0x50,
    // code hash value
    0x58, 0x40,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
    0x63, 0x63, 0x63, 0x63,
    // code descriptor (-4670546)
    0x3a, 0x00, 0x47, 0x44, 0x51,
    // code descriptor value ("code")
    0x44, 0x63, 0x6f, 0x64, 0x65,
    // configuration hash (-4670547)
    0x3a, 0x00, 0x47, 0x44, 0x52,
    // configuration hash value
    0x58, 0x40,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
    0x65, 0x65, 0x65, 0x65,
    // configuration descriptor (-4670548)
    0x3a, 0x00, 0x47, 0x44, 0x53,
    // configuration descriptor value ("config")
    0x46, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
    // authority hash (-4670549)
    0x3a, 0x00, 0x47, 0x44, 0x54,
    // authority hash value
    0x58, 0x40, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
    // authority descriptor (-4670550)
    0x3a, 0x00, 0x47, 0x44, 0x55,
    // authority descriptor value ("auth")
    0x44, 0x61, 0x75, 0x74, 0x68,
    // mode (-4670551)
    0x3a, 0x00, 0x47, 0x44, 0x56,
    // mode value
    0x41, 0x01,
    // Subject public key (-4670552)
    0x3a, 0x00, 0x47, 0x44, 0x57,
    // Subject public key value
    // byte string header
    0x58, 0x51,
    // map header with 6 pairs
    0xa6,
    // Key Type (1)
    0x01,
    // Key type value (EC2)
    0x02,
    // Key Algorithm (3)
    0x03,
    // Key Algorithm value (ESP256: -9)
    0x28,
    // Cose Key Ops (4)
    0x04,
    // Cose Key Ops value (Sign: 1, Verify: 2)
    0x82, 0x01, 0x02,
    // Curve type (-1)
    0x20,
    // Curve type value (P256: 1)
    0x01,
    // X coordinate (-2)
    0x21,
    // X coordinate value
    0x58, 0x20, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    // Y coordinate (-3)
    0x22,
    // Y coordinate value
    0x58, 0x20, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x39, 0x38, 0x37, 0x36,
    0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
    0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,

    // Key Usage (-4670553)
    0x3a, 0x00, 0x47, 0x44, 0x58,
    // Key Usage value
    0x40
};

std::vector<uint8_t> const EXTENSION_WITHOUT_OPTIONALS = {
    // Map header with 5 pairs.
    0xa5,
    // issuer (1).
    0x01,
    // issuer value
    0x78, 0x28, 0x30, 0x31, 0x30, 0x32, 0x30, 0x33, 0x30, 0x34, 0x30, 0x35,
    0x30, 0x36, 0x30, 0x37, 0x30, 0x38, 0x30, 0x39, 0x30, 0x61, 0x30, 0x62,
    0x30, 0x63, 0x30, 0x64, 0x30, 0x65, 0x30, 0x66, 0x31, 0x30, 0x31, 0x31,
    0x31, 0x32, 0x31, 0x33, 0x31, 0x34,
    // subject (2)
    0x02,
    // subject value
    0x78, 0x28, 0x31, 0x35, 0x31, 0x36, 0x31, 0x37, 0x31, 0x38, 0x31, 0x39,
    0x31, 0x61, 0x31, 0x62, 0x31, 0x63, 0x31, 0x64, 0x31, 0x65, 0x31, 0x66,
    0x32, 0x30, 0x32, 0x31, 0x32, 0x32, 0x32, 0x33, 0x32, 0x34, 0x32, 0x35,
    0x32, 0x36, 0x32, 0x37, 0x32, 0x38,
    // mode (-4670551)
    0x3a, 0x00, 0x47, 0x44, 0x56,
    // mode value
    0x41, 0x00,
    // Subject public key (-4670552)
    0x3a, 0x00, 0x47, 0x44, 0x57,
    // Subject public key value
    // byte string header
    0x58, 0x51,
    // map header with 6 pairs
    0xa6,
    // Key Type (1)
    0x01,
    // Key type value (EC2)
    0x02,
    // Key Algorithm (3)
    0x03,
    // Key Algorithm value (ESP256: -9)
    0x28,
    // Cose Key Ops (4)
    0x04,
    // Cose Key Ops value (Sign: 1, Verify: 2)
    0x82, 0x01, 0x02,
    // Curve type (-1)
    0x20,
    // Curve type value (P256: 1)
    0x01,
    // X coordinate (-2)
    0x21,
    // X coordinate value
    0x58, 0x20, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    // Y coordinate (-3)
    0x22,
    // Y coordinate value
    0x58, 0x20, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x39, 0x38, 0x37, 0x36,
    0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
    0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,

    // Key Usage (-4670553)
    0x3a, 0x00, 0x47, 0x44, 0x58,
    // Key Usage value
    0x40
};
// clang-format on

std::string const AURORA_OPEN_DICE_PROFILE = "Aurora OpenDICE Profile";

INSTANTIATE_TEST_CASE_P(OpenDiceInputEncoding,
                        COSEExtOpenDiceInputTest,
                        testing::Values(std::tuple(CODE_HASH,
                                                   CODE_DESCRIPTOR,
                                                   std::nullopt,
                                                   CONFIGURATION_INLINE,
                                                   AUTHORITY_HASH,
                                                   AUTHORITY_DESCRIPTOR,
                                                   n20_cwt_open_dice_normal_e,
                                                   AURORA_OPEN_DICE_PROFILE,
                                                   EXTENSION_WITH_INLINE_CONFIGURATION),
                                        std::tuple(CODE_HASH,
                                                   CODE_DESCRIPTOR,
                                                   CONFIGURATION_HASH,
                                                   CONFIGURATION_DESCRIPTOR,
                                                   AUTHORITY_HASH,
                                                   AUTHORITY_DESCRIPTOR,
                                                   n20_cwt_open_dice_normal_e,
                                                   AURORA_OPEN_DICE_PROFILE,
                                                   EXTENSION_WITH_CONFIGURATION_DESCRIPTOR),
                                        std::tuple(std::nullopt,
                                                   std::nullopt,
                                                   std::nullopt,
                                                   std::nullopt,
                                                   std::nullopt,
                                                   std::nullopt,
                                                   n20_cwt_open_dice_not_configured_e,
                                                   std::nullopt,
                                                   EXTENSION_WITHOUT_OPTIONALS)));

template <typename T>
inline static n20_slice_t v2slice(T const &v) {
    if (v.has_value()) {
        return n20_slice_t{v->size(), v->data()};
    }
    return N20_SLICE_NULL;
}

TEST_P(COSEExtOpenDiceInputTest, OpenDiceInputEncoding) {
    auto [optional_code_hash,
          optional_code_descriptor,
          optional_configuration_hash,
          optional_configuration_descriptor,
          optional_authority_hash,
          optional_authority_descriptor,
          mode,
          optional_profile,
          expected] = GetParam();

    std::vector<uint8_t> issuer_data = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
                                        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14};
    std::vector<uint8_t> subject_data = {0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
                                         0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
                                         0x23, 0x24, 0x25, 0x26, 0x27, 0x28};

    n20_open_dice_cwt_t cwt = {};
    cwt.key_usage[0] = 0x01;
    cwt.key_usage[1] = 0x00;
    cwt.subject_public_key.algorithm_id = -9;  // Example algorithm ID
    n20_set_cose_key_ops(&cwt.subject_public_key.key_ops, n20_cose_key_op_sign_e);
    n20_set_cose_key_ops(&cwt.subject_public_key.key_ops, n20_cose_key_op_verify_e);
    cwt.subject_public_key.x = {.size = 32,
                                .buffer = (uint8_t *)"0123456789abcdef0123456789abcdef"};
    cwt.subject_public_key.y = {.size = 32,
                                .buffer = (uint8_t *)"fedcba9876543210fedcba9876543210"};
    cwt.subject_public_key.d = {.size = 0, .buffer = nullptr};  // No private key
    cwt.issuer = {.size = 20, .buffer = (uint8_t *)issuer_data.data()};
    cwt.subject = {.size = 20, .buffer = (uint8_t *)subject_data.data()};
    cwt.code_hash = v2slice(optional_code_hash);
    cwt.code_descriptor = v2slice(optional_code_descriptor);
    cwt.configuration_hash = v2slice(optional_configuration_hash);
    cwt.configuration_descriptor = v2slice(optional_configuration_descriptor);
    cwt.authority_hash = v2slice(optional_authority_hash);
    cwt.authority_descriptor = v2slice(optional_authority_descriptor);
    cwt.mode = mode;

    n20_stream_t s;
    n20_stream_init(&s, nullptr, 0);
    n20_open_dice_cwt_write(&s, &cwt);
    ASSERT_FALSE(n20_stream_has_write_position_overflow(&s));
    size_t bytes_written = n20_stream_byte_count(&s);
    std::vector<uint8_t> buffer(bytes_written);
    n20_stream_init(&s, buffer.data(), buffer.size());
    n20_open_dice_cwt_write(&s, &cwt);

    ASSERT_FALSE(n20_stream_has_buffer_overflow(&s));
    size_t bytes_written_again = n20_stream_byte_count(&s);
    ASSERT_EQ(bytes_written_again, bytes_written);
    ASSERT_EQ(buffer, expected) << "Expected: " << hex(expected) << ", Got: " << hex(buffer);
}
